-> vault accepts both AMPL/USDC in the tranche ratio based on the AMPL target price (or oracle price)?
-> getTVL()? spot.getTVL, vault.getTVL, ampl_bal + tranche_cdr

(100 AMPL, 25 USDC)[ 1 : 4 ]

-> tranches_

-> deploy
	-> deposit2()
	-> deposits SPOT - USDC into Liquidity position (given uni pool address and AMPL/USDC target, perp price in AMPL)
		-> put 20% in inf band
		-> put 20% in [1.15 - 2.5]
		-> put 60% in [1.15 - 1.35]

-> recover()
	-> unwind x% of liquidity (spot_usdc)
	-> redeem2(spot_bal, max_stampl_bal)

-> Rebalance, every x seconds  
	-> recover() && deploy(){}

-> system is under-subscribed
=> gradually pull liquidity and redeem all the spot

-> system is over-subscribed
=> rebalance() and deploy everything

ampl_cl_spot price
ampl_target
USDC price

can deposit either AMPL or USDC, when they withdraw they will get a blend of vault assets.


Tranche V2


Bond vault => createBond(collateral, seniorRatio, juniorRatio, maturityDate)
	=> create A and Z tranches

tranche.mature()
tranche.maturityDate()
tranche.index() [senior or junior]
tranche.bond() -> revert()
tranche.bondID() -> id_hash
tranche.ratio() (ratio, Granularity)
tranche.version() -> 2
tranche.underlying()
tranche.vault() -> parent bond vault!
tranche.getCDR() -> vault.getCDR(bondID)
tranche.mature() -> vault.mature(bondID)
tranche.isMature() -> vault.isMature(bondID)


// tranche.redeem() -> vault.redeemAll(bondID) (only works after maturity)
// vault can be upgradable, but tranche does not have to be, only whitelist at first
// use a library function to go from rebasing to non-rebasing
// Lazy mature?

vault.createBond() -> random salt, check if is button token or AMPL

vault.getTVL()
vault.trancheCount(id)
vault.getTranches()
vault.getTrancheRatios()
vault.getTranche(id, index)
vault.getTrancheRatio(id, index)
vault.getTrancheCDR(id, index)
vault.getCDR(id)
vault.underlying(id)
vault.isValidTranche(id, tranche); round trip check
vault.maturityDate(id)
vault.duration(id)
vault.secondsToMaturity(id)
vault.totalDebt(id)

vault.upForMaturity(id)
vault.mature(id)
vault.isMature()

BondData, seniorAmt, juniorAmt
[DepositData]vault.deposit(id, amount)
previewDeposit() ? (as helpers)

BondData, seniorAmtBurnt, juniorAmtBurnt
[RedemptionData] vault.redeem(id) [ redeems all and handles state ]
previewRedeem() ? (as helpers)

vault.redeemEarly(id, amountsAvailable)
vault.redeemMature(id, index, amount)

vault.getBondData(id) -> {
	seniorTranche ->
	juniorTranche ->
	totalDebt ->
	mapping(totalScaledCollateralBalance[user]) -> 
	totalCollateralBalance -> infer
}
// delete bond data, after total debt goes to zero and bond is mature.


// next version, no rush
// vault.rollover(id1, id2) => {redeemAll() and deposit()}
// perp should implement flash rollover!

// are bank runs possible given choice of assets!
// run conditions?

Ensure balancer fee flows works properly!
rebalancer whitelist

// does redeemVaultNotesAndMintPerps really need a fee
it decreases dr, only allowed when dr > 1[]
it results in STAMPL supply reducing and perp supply increasing which makes sense to not charge a fee
however, it could be used as the default redemption function 


// Refine AMPL-USDC vault idea,
increase spot usdc liquidity
there are 2 problems we need the right kind of amm
and we want spot supply in the pool to grow and shrink

Next week
Deployment of v2 to testnet and perfrom all ops
Update test cases, make sure the fees work properly
Setup monitoring dashboard for perp and vault 

Week after (balancer)
Remove router, update fee policy into balancer
Remove update state form perp
Vault and perp can only interact through the balancer
mock balancer to allow testing!

Balancer methods (use existing impl)
mintp_()
mintp_(tranche), redeemp
mintv, redeemv
mint2, redeem2
redeemp, mintv
redeemv, mintp
rebalance()

Week after that()
SPOT-USDC pool


100, 300 => 100,400

25 => 5, 20

Move trancheAndDepsot, redeem2 to router
Handle offchain jobs! defender
Rebalance charm every 6 days! (interm solution)


Move the base charm vault rebalance job back to eng defender!!!